

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/blogger-logo.png">
  <link rel="icon" href="/img/blogger-logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Binbiubiu">
  <meta name="keywords" content="">
  
    <meta name="description" content="ListArrayList的扩容机制 扩容是懒惰式的，即：没有添加元素之前，即使指定了容量，也不会真正的创建数组。  add(Object o) 方法首次扩容为10，再次扩容：创建一个为原来容量1.5倍（&#x3D;原来容量+原来容量&gt;&gt;1） 的，将原来的复制过来，再添加一个元素进去。  addAll(Collection c) 首次扩容为 Math.max(10, 实际元素个数)。再次扩容（有">
<meta property="og:type" content="article">
<meta property="og:title" content="面试笔记">
<meta property="og:url" content="https://binbiubiu.github.io/20190101181900/index.html">
<meta property="og:site_name" content="Binbiubiu&#39;s blog">
<meta property="og:description" content="ListArrayList的扩容机制 扩容是懒惰式的，即：没有添加元素之前，即使指定了容量，也不会真正的创建数组。  add(Object o) 方法首次扩容为10，再次扩容：创建一个为原来容量1.5倍（&#x3D;原来容量+原来容量&gt;&gt;1） 的，将原来的复制过来，再添加一个元素进去。  addAll(Collection c) 首次扩容为 Math.max(10, 实际元素个数)。再次扩容（有">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230301165301641.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230301171302753.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230302190512791.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230303165422780.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230303220105748.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230303170124012.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230303220224329.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230303230619879.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304005229494.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304005348282.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304005405565.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304011018225.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304011623249.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304011645447.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304011834362.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304161451547.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304162323655.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304162445334.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304162520513.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304162621644.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304162720475.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304162749996.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304163017504.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230304163140472.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230305132528648.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230305132802644.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230305132952463.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230306122237450.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230306124500835.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230306130142595.png">
<meta property="og:image" content="https://binbiubiu.github.io/20190101181900/image-20230306130602793.png">
<meta property="article:published_time" content="2019-01-01T10:19:00.000Z">
<meta property="article:modified_time" content="2023-03-17T02:11:30.035Z">
<meta property="article:author" content="Binbiubiu">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://binbiubiu.github.io/20190101181900/image-20230301165301641.png">
  
  
  
  <title>面试笔记 - Binbiubiu&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"binbiubiu.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>BinBiuBiu&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-01-01 18:19" pubdate>
          2019年1月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          187 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><ul>
<li><p>扩容是懒惰式的，即：没有添加元素之前，即使指定了容量，也不会真正的创建数组。</p>
</li>
<li><p><code>add(Object o)</code> 方法首次扩容为10，再次扩容：创建一个为原来容量1.5倍<code>（=原来容量+原来容量&gt;&gt;1）</code> 的，将原来的复制过来，再添加一个元素进去。</p>
</li>
<li><p><code>addAll(Collection c)</code> 首次扩容为 <code>Math.max(10, 实际元素个数)</code>。再次扩容（有元素时）为 <code>Math.max(原来1.5倍, 实际元素个数)</code>。</p>
</li>
</ul>
<h2 id="Fail-Fast-和-Fail-Safe"><a href="#Fail-Fast-和-Fail-Safe" class="headerlink" title="Fail-Fast 和 Fail-Safe"></a>Fail-Fast 和 Fail-Safe</h2><ul>
<li><p>Fail-Fast</p>
<p>ArrayList是Fail-Fast的典例，遍历时不可修改。</p>
<p>在增强for循环的地方进行断点调试，进入断点会发现创建了一个迭代器，迭代器在初始化的时候，会进行相关成员变量的初始化。在迭代器判断是否有下一个元素的时候，next()方法校验如果发现list的修改次数（modCount）发生了改变，则直接抛出<code>ConcurrentModificationException</code>异常。</p>
</li>
<li><p>Fail-Safe</p>
<p>CopyOnWriteArrayList是Fail-Safe的典例，遍历时可修改，原理是读写分离。</p>
<p>在遍历的时候，我们会发现，它使用的是一个叫 <code>COWIterator</code> 迭代器，它实际遍历的是原始数据集合的一个快照。通过在调用 <code>add()</code> 方法添加元素的时候，我们也可以看到，它本身也是对数组进行了一个复制。</p>
</li>
</ul>
<h2 id="ArrayList-与-LinkedList-的比较"><a href="#ArrayList-与-LinkedList-的比较" class="headerlink" title="ArrayList 与 LinkedList 的比较"></a>ArrayList 与 LinkedList 的比较</h2><ul>
<li>ArrayList<ol>
<li>基于数组，需要连续存储。</li>
<li>随机访问快（根据下标访问）。</li>
<li>尾部插入、删除性能可以，其他部分插入、删除都会移动数据，因此性能会低。</li>
<li>可以利用cpu缓存，局部性原理（系统认为：某一元素相邻的一些数据也是有很大概率会被访问，所以读取某一元素时会将相邻的一些数据同时缓存，提高处理效率。但是链表结构的就不行，因为指针指向的下一元素大可能并不在相邻位置）。</li>
</ol>
</li>
<li>LinkedList<ol>
<li>基于双向链表，无需连续存储。</li>
<li>随机访问慢（要沿着链表遍历）。</li>
<li>头尾插入删除性能高。</li>
<li>占用内存多。</li>
</ol>
</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="底层数据结构1-7和1-8的不同？"><a href="#底层数据结构1-7和1-8的不同？" class="headerlink" title="底层数据结构1.7和1.8的不同？"></a>底层数据结构1.7和1.8的不同？</h2><ul>
<li>1.7：数组 + 链表。</li>
<li>1.8：数组 + 链表或者红黑树。红黑树可以避免链表过长的情况。</li>
</ul>
<h2 id="使用红黑树的意义？"><a href="#使用红黑树的意义？" class="headerlink" title="使用红黑树的意义？"></a>使用红黑树的意义？</h2><ul>
<li><p>为何要使用红黑树？</p>
<p>红黑树：自平衡二叉树，每一个节点上，小的在左边节点，大的在右边节点。</p>
</li>
<li><p>为什么不一上来就树化？</p>
<ol>
<li>链表短的情况下，树化并不会提高性能。</li>
<li>链表的成员变量是node，树的成员变量是treeNode，占用的内存会更多一点。</li>
</ol>
</li>
<li><p>树化的阈值为何是8？</p>
<p>正常情况下，链表的长度不会超过8。</p>
<p>红黑树用来避免DoS攻击，防止链表超长时性能下降，树化应当是偶然现象，选择8就是为了让树化的几率足够小。</p>
</li>
<li><p>链表何时会树化？</p>
<p>需要同时满足2个条件：</p>
<ol>
<li>链表长度超过阈值8。</li>
<li>整个数组的长度要大于等于64，没到64会优先进行扩容。</li>
</ol>
</li>
<li><p>何时会退化为链表？</p>
<p>情况1：扩容时，如果拆分树后，树元素个数 &lt;&#x3D;6 则会退化链表。</p>
<p>情况2：remove树节点前检查：若root、root.left、root.right、root.left.left有一个为null，则会退化为链表。</p>
</li>
</ul>
<h2 id="索引（桶下标）的计算"><a href="#索引（桶下标）的计算" class="headerlink" title="索引（桶下标）的计算"></a>索引（桶下标）的计算</h2><ol>
<li><p>计算对象的hashCode，再调用 <code>HashMap的hash()</code> 方法进行二次哈希，最后求模运算（%capacity）得到索引。</p>
</li>
<li><p>二次哈希是为了综合高位的数据，让哈希分布更为均匀。</p>
</li>
<li><p>为什么数组容量为2的n次幂？因为2的n次幂可以使用位与运算代替取模，效率更高；</p>
<p>扩容的时候，如果 hash &amp; oldCapacity &#x3D;&#x3D; 0 的元素留在原来的位置，</p>
<p>否则，新位置 &#x3D; 旧位置 + oldCapacity。</p>
</li>
<li><p>扩容负载因子：0.75，即：当元素达到容量的3&#x2F;4时，进行扩容。</p>
</li>
</ol>
<h2 id="HashMap-put流程"><a href="#HashMap-put流程" class="headerlink" title="HashMap put流程"></a>HashMap put流程</h2><ul>
<li><p>HashMap是懒惰式创建数组，首次使用的时候才创建数组。</p>
</li>
<li><p>计算索引（桶下标）：</p>
<ul>
<li><p>如果桶下标还没被占用：</p>
<p>创建Node占位返回。<em>（多线程这边可能会引发丢失问题）</em></p>
</li>
<li><p>如果桶下标已经被占用：</p>
<p>如果已经是TreeNode走红黑树的添加或者更新逻辑；</p>
<p>如果是普通的Node，走链表的添加或修改逻辑，如果是长度超过树化阈值的，走树化逻辑。</p>
</li>
</ul>
</li>
<li><p>返回前检查容量是否超过阈值，一旦超过进行扩容。</p>
</li>
<li><p>put 方式在 Java 1.7和1.8中的不同：</p>
<ol>
<li><p>链表插入节点时，1.7是头插法，1.8是尾插法。</p>
<p><em>注：头插法在扩容后，链表顺序会发生改变，因为重新插入，所以顺序会反过来。多线程当中，头插法在扩容后可能会存在死链问题（即：a -&gt; b -&gt; a）</em></p>
</li>
<li><p>1.7是大于等于阈值且没有空位的时候才扩容，1.8是大于阈值就扩容。</p>
</li>
<li><p>1.8在扩容计算Node索引的时候，会优化。</p>
</li>
</ol>
</li>
<li><p>负载因子为什么默认是0.75f</p>
<p>在空间占用与查询时间之间取得较好的平衡：</p>
<ul>
<li><p>大于这个值，空间节省了，但链表就会变长影响性能。</p>
</li>
<li><p>小于这个值，冲突减少了，但扩容就会更频繁，空间占用更多。</p>
</li>
</ul>
</li>
</ul>
<h2 id="HashMap在多线程下的问题"><a href="#HashMap在多线程下的问题" class="headerlink" title="HashMap在多线程下的问题"></a>HashMap在多线程下的问题</h2><ol>
<li>扩容死链（1.7，参考put流程扩容后的头插法）</li>
<li>数据混乱（1.7和1.8，参考put流程索引计算）</li>
</ol>
<h2 id="HashMap的key能否位null，作为key的对象有什么要求"><a href="#HashMap的key能否位null，作为key的对象有什么要求" class="headerlink" title="HashMap的key能否位null，作为key的对象有什么要求"></a>HashMap的key能否位null，作为key的对象有什么要求</h2><ul>
<li>HashMap 的key可以位null。</li>
<li>作为key的对象，必须重写 hashCode()和equals()方法，并且key的内容不可变（比如我们常用的String就是不可变的，作为key，如果是自定义对象，对象发生了改变，就没法通过key的hashCode找到value）。</li>
</ul>
<h2 id="String-的-hashCode如何设计的，为什么是每次乘以31"><a href="#String-的-hashCode如何设计的，为什么是每次乘以31" class="headerlink" title="String 的 hashCode如何设计的，为什么是每次乘以31"></a>String 的 hashCode如何设计的，为什么是每次乘以31</h2><p>目的是为了达到较为均匀的散列效果，每个字符串的hashCode足够独特。 </p>
<p>根据其散列公式得知：31带入公式有较好的散列特性，并且 <code>31 * h</code> 可以被优化为：</p>
<p><code>32 * h - h</code> 等价于： <code>2^5 * h - h</code> 等价于： <code>h &lt;&lt; 5 - h</code></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="常见单例模式"><a href="#常见单例模式" class="headerlink" title="常见单例模式"></a>常见单例模式</h3><ol>
<li><p>饿汉式 - 静态代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单例模式 - 饿汉式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 判断，避免通过反射的方式再创建对象</span><br>        <span class="hljs-keyword">if</span>(INSTANCE != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;单例对象不能被重复创建！&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;private Singleton1()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton1</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton1</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;otherMethod()...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 特殊方法，可以避免反序列化破坏单例</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>饿汉式 - 枚举。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单例模式 - 饿汉式</span><br><span class="hljs-comment"> * 枚举类方式</span><br><span class="hljs-comment"> * 优点：</span><br><span class="hljs-comment"> * 1. 可以避免反序列化破坏单例。</span><br><span class="hljs-comment"> * 2. 可以避免反射破坏单例。（枚举不能通过反射创建实例）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton2</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 枚举变量（本身就是公共的，不提供公共方法也能使用）</span><br><span class="hljs-comment">     */</span><br>    INSTANCE;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数（可省略）</span><br><span class="hljs-comment">     */</span><br>    Singleton2()&#123;<br>        System.out.println(<span class="hljs-string">&quot;private Singleton2()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写，方便查看实例的信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>懒汉式 - DCL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单例模式 - 懒汉式 - DCL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton3</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;private Singleton3()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * volatile 保证可见性，有序性，避免指令重排。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton3</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton3.class)&#123;<br>                <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)&#123;<br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton3</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;otherMethod()...&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>懒汉式 - 静态内部类方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> pattern;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单例模式 - 懒汉式 - 静态内部类方式</span><br><span class="hljs-comment"> * 原理：静态代码块具有线程安全的特性。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton4</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;private Singleton4()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态内部类方式的懒汉单例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span> &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton4</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton4</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton4 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Holder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">otherMethod</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;otherMethod()...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="破坏单例的方式"><a href="#破坏单例的方式" class="headerlink" title="破坏单例的方式"></a>破坏单例的方式</h3><ul>
<li><p>反射破坏单例</p>
<p>可避免：构造函数中添加实例是否为空的判断，因为反射是通过构造函数来创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 破坏单例 - 通过反射创建实例</span><br><span class="hljs-comment"> * 避免方式：可以通过构造函数添加判断来避免。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> clazz</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();<br>    constructor.setAccessible(<span class="hljs-literal">true</span>);<br>    System.out.println(<span class="hljs-string">&quot;反射创建的实例：&quot;</span> + constructor.newInstance());<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>反序列化破坏单例</p>
<p>可避免：单例类中添加 <code>readResolve()</code> 方法，方法中返回实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 破坏单例 - 通过反序列化创建实例</span><br><span class="hljs-comment"> * 避免方式：可以通过添加特殊方法 readResolve() 来避免。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> instance</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serializable</span><span class="hljs-params">(Object instance)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>    oos.writeObject(instance);<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray()));<br>    System.out.println(<span class="hljs-string">&quot;反序列化创建的实例：&quot;</span> + ois.readObject());<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
<li><p>Unsafe破坏单例</p>
<p>无法避免。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 破坏单例 - 通过 Unsafe 创建实例</span><br><span class="hljs-comment"> * 避免方式：无法避免。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> clazz</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstantiationException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsafe</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> InstantiationException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> UnsafeUtils.getUnsafe().allocateInstance(clazz);<br>    System.out.println(<span class="hljs-string">&quot;Unsafe创建的实例：&quot;</span> + o);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="JDK中哪些地方使用了单例模式"><a href="#JDK中哪些地方使用了单例模式" class="headerlink" title="JDK中哪些地方使用了单例模式"></a>JDK中哪些地方使用了单例模式</h3><ul>
<li>Runtime（System.exit()和System.gc()方法的底层），饿汉式的单例。</li>
<li>System中的Console对象，是一个双检锁形式的单例。</li>
<li>Collections中静态内部类，如 EmptyXXX。</li>
<li>Comparator中的Comparators.NaturalOrderComparator.INSTANCE，是一个枚举形式的单例。</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="线程有哪些状态"><a href="#线程有哪些状态" class="headerlink" title="线程有哪些状态"></a>线程有哪些状态</h2><ul>
<li>new，新建</li>
<li>runnable，可运行</li>
<li>blocked，阻塞</li>
<li>waiting，等待</li>
<li>timed_waiting，有时限等待</li>
<li>terminated，终止</li>
</ul>
<p><img src="/20190101181900/image-20230301165301641.png" srcset="/img/loading.gif" lazyload alt="image-20230301165301641"></p>
<h2 id="sleep-和-wait-的比较"><a href="#sleep-和-wait-的比较" class="headerlink" title="sleep() 和 wait() 的比较"></a>sleep() 和 wait() 的比较</h2><ul>
<li>方法归属不同<ul>
<li>sleep()是Thread的静态方法。</li>
<li>wait()是Object的成员方法，每个对象都有。</li>
</ul>
</li>
<li>唤醒时机不一样<ul>
<li>sleep()和wait()都会在等待相应时间后醒来。</li>
<li>wait()还可以被notify()唤醒。</li>
<li>都可以被打断唤醒。</li>
</ul>
</li>
<li>锁特性不一样<ul>
<li>wait()方法的调用必须先获取wait()对象的锁，而sleep()则不用。</li>
<li>wait()方法执行后会释放对象锁，允许其他线程获得该对象锁。</li>
<li>sleep()方法如果在synchronized代码块中，并不会释放锁。</li>
</ul>
</li>
</ul>
<h2 id="实现线程的方式"><a href="#实现线程的方式" class="headerlink" title="实现线程的方式"></a>实现线程的方式</h2><ol>
<li><p>继承Thread类，重写run()方法。</p>
<p>1）可以将线程类抽象出来，当需要使⽤抽象⼯⼚模式设计时。 </p>
<p>2）多线程同步。</p>
</li>
<li><p>实现Runnable接口，重写run()方法，将实现类的实例作为Thread构造函数的target。</p>
<p>1）适合多个相同的程序代码的线程去处理同⼀个资源。</p>
<p>2）可以避免java中的单继承的限制。</p>
<p>3）增加程序的健壮性，代码可以被多个线程共享，代码和数据独⽴。</p>
</li>
<li><p>通过线程池创建。</p>
</li>
<li><p>实现Callable接口，通过FutureTask包装器来创建Thread线程。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> thread;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Callable&lt;Object&gt; oneCallable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tickets</span>&lt;Object&gt;();<br>        FutureTask&lt;Object&gt; oneTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;Object&gt;(oneCallable);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(oneTask);<br>        System.out.println(Thread.currentThread().getName());<br>        t.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tickets</span>&lt;Object&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Object&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;--&gt;我是通过实现Callable接⼝通过FutureTask包装器来实现的线程&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="锁的等级：⽅法锁、对象锁、类锁"><a href="#锁的等级：⽅法锁、对象锁、类锁" class="headerlink" title="锁的等级：⽅法锁、对象锁、类锁"></a>锁的等级：⽅法锁、对象锁、类锁</h2><ol>
<li>⽅法锁（synchronized修饰⽅法时）</li>
<li>对象锁（synchronized修饰⽅法或代码块）</li>
<li>类锁（synchronized 修饰静态的⽅法或代码块）</li>
</ol>
<p>对象锁是⽤来控制实例⽅法之间的同步，类锁是⽤来控制静态⽅法（或静态变量互斥体）之间的同步。</p>
<h2 id="如何保证多线程下-i-结果正确？"><a href="#如何保证多线程下-i-结果正确？" class="headerlink" title="如何保证多线程下 i++ 结果正确？"></a>如何保证多线程下 i++ 结果正确？</h2><ol>
<li>volatile只能保证你数据的可⻅性，获取到的是最新的数据，不能保证原⼦性； </li>
<li>⽤AtomicInteger保证原⼦性。 </li>
<li>synchronized既能保证共享变量可⻅性，也可以保证锁内操作的原⼦性。</li>
</ol>
<h2 id="如果同步块内的线程抛出异常会发⽣什么？"><a href="#如果同步块内的线程抛出异常会发⽣什么？" class="headerlink" title="如果同步块内的线程抛出异常会发⽣什么？"></a>如果同步块内的线程抛出异常会发⽣什么？</h2><p>synchronized⽅法正常返回或者抛异常⽽终⽌，JVM会⾃动释放对象锁。</p>
<h2 id="Lock和synchronized两种锁的比较"><a href="#Lock和synchronized两种锁的比较" class="headerlink" title="Lock和synchronized两种锁的比较"></a>Lock和synchronized两种锁的比较</h2><ul>
<li><p>语法层面</p>
<ul>
<li>synchronized 是关键字，源码在jvm中，用c++实现。</li>
<li>Lock是接口，源码由jdk提供，用java实现。</li>
<li>使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock()方法释放。</li>
</ul>
</li>
<li><p>功能层面</p>
<ul>
<li><p>二者都是悲观锁，都具备基本的互斥、同步、锁重入功能。</p>
</li>
<li><p>Lock提供了许多synchronized不具备的功能，例如获取等待状态、公平锁（先到先得）、可打断、可超时、多条件变量。</p>
<p>注：无参的tryLock()方法是非公平锁，有参的tryLock()是根据配置判断是否公平锁。</p>
</li>
<li><p>Lock有适合不同场景的实现，如ReentrantLock。</p>
</li>
</ul>
</li>
<li><p>性能层面</p>
<ul>
<li>在没有竞争的时，synchronized做了优化，如偏向锁、轻量级锁，性能不错。</li>
<li>在竞争激烈时，Lock的实现通常会提供更好的性能。</li>
</ul>
</li>
</ul>
<h2 id="volatile-能否保证线程安全"><a href="#volatile-能否保证线程安全" class="headerlink" title="volatile 能否保证线程安全"></a>volatile 能否保证线程安全</h2><p>线程安全主要考虑三个方面：可见性、有序性、原子性。</p>
<ul>
<li>可见性，一个线程对共享变量修改，另一个线程能看到最新的结果。</li>
<li>有序性，一个线程内代码按照编写的顺序执行。</li>
<li>原子性，一个线程内多行代码以一个整体运行，期间不能有其他线程的代码插队。</li>
</ul>
<p>volatile 能够保证共享变量的可见性和有序性，但不能保证原子性，所以还是会有线程安全的问题。</p>
<h2 id="volatile-读写屏障"><a href="#volatile-读写屏障" class="headerlink" title="volatile 读写屏障"></a>volatile 读写屏障</h2><ul>
<li><p>写屏障：在写指令之后插入写屏障，强制把写缓冲区的数据刷回到主内存中。</p>
</li>
<li><p>读屏障：在读指令之前插入读屏障，让工作内存或CPU高速缓存当中的缓存数据失效，重新回到主内存中获取最新数据。</p>
</li>
</ul>
<h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><ul>
<li><p>悲观锁的代表是synchronized和Lock锁</p>
<ul>
<li>核心思想：线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都必须停下来等待。</li>
<li>线程从运行到阻塞，再从阻塞到唤醒，这种状态的切换涉及线程上下文切换（每次操作都要记录与恢复上一次的执行位置），如果频繁发生，影响性能。所以实际上，线程在获取synchronized和Lock锁时，如果锁已经被占用，都会做几次重试操作，减少阻塞的机会。</li>
</ul>
</li>
<li><p>乐观锁的代表是AtomicInteger，使用<strong>CAS（Compare And Swap）</strong>来保证原子性。</p>
<ul>
<li><p>核心思想：无需加锁，每次只有一个线程能成功修改变量，其他失败的线程不需要停止，<em><strong>不断重试</strong></em>直至成功。</p>
</li>
<li><p>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换。</p>
</li>
<li><p>它需要多核CPU支持，且线程数不应超过CPU核数。</p>
<p><em><strong>附：这里提到的cas指的是Unsafe.compareAndSetXXX()，该方法可以保证操作的原子性，方法返回一个boolean（true&#x2F;修改成功，false&#x2F;修改失败）。</strong></em></p>
</li>
</ul>
</li>
</ul>
<h3 id="CAS与ABA问题"><a href="#CAS与ABA问题" class="headerlink" title="CAS与ABA问题"></a>CAS与ABA问题</h3><h2 id="Hashtable和ConcurrentHashMap的比较"><a href="#Hashtable和ConcurrentHashMap的比较" class="headerlink" title="Hashtable和ConcurrentHashMap的比较"></a>Hashtable和ConcurrentHashMap的比较</h2><ol>
<li><p>Hashtable与ConcurrentHashMap都是线程安全的Map集合。</p>
</li>
<li><p>Hashtable并发度低，整个Hashtable对应一把锁，同一时刻，只能有一个线程操作它。</p>
</li>
<li><p>ConcurrentHashMap：</p>
<ul>
<li><p>在1.8之前，使用Segment数组+HashEntry小数组+链表的结构，每个Segment对应一把锁，如果多个线程访问不同的Segment，则不会冲突。</p>
<p><em><strong>注：Segment数（clevel）确认后不会扩容，能扩容的是HashEntry小数组。Segment[0]作为原型，Segment[0]的小数组容量的初始值&#x3D;capacity&#x2F;clevel，在Segment[n]上新建小数组的初始容量等于Segment[0]的，如果Segment[0]的小数组容量发生了扩容，那么之后的Segment[x]在新建时的小数组容量也是等于新的Segment[0]的小数组容量。</strong></em></p>
</li>
<li><p>在1.8之后，ConcurrentHashMap将数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。</p>
<p><em><strong>注：构造参数代表的含义不同，capacity 指的是将要放的元素个数，系统需要根据这个数自行计算初始容量。factor指的是初始化容量时扩容的阈值的负载因子，之后的扩容阈值的负载因子还是0.75。</strong></em></p>
<p>每个节点在处理完（迁移）之后，会被标记为forwardingNode，其他线程访问的时候，将会直接到达新的map对应的新的节点上。</p>
</li>
</ul>
</li>
</ol>
<h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><ul>
<li>corePoolSize，核心线程数目，最多保留的线程数。</li>
<li>maximumPoolSize，最大线程数目，即：核心线程+救急线程。</li>
<li>keepAliveTime，生存时间，针对救急线程。</li>
<li>unit，时间单位，针对救急线程。</li>
<li>workQueue，任务阻塞队列。</li>
<li>threadFactory，线程工厂，可以为线程创建时起个好名字。</li>
<li>handler，拒绝策略，超过最大线程数时的策略，四种：<ul>
<li>ThreadPoolExecutor.AbortPolicy()，抛出异常。</li>
<li>ThreadPoolExecutor.CallerRunsPolicy()，由调用者去执行该任务，比如调用者是主线程，则由main函数去执行该任务。</li>
<li>ThreadPoolExecutor.DiscardPolicy()，直接丢弃任务。</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy()，丢弃任务队列中已经等待最久的任务。</li>
</ul>
</li>
</ul>
<p><img src="/20190101181900/image-20230301171302753.png" srcset="/img/loading.gif" lazyload alt="image-20230301171302753"></p>
<p>执行流程：</p>
<p>submit()后，如果核心线程以及任务队列都满了，就会创建救急线程。</p>
<p>submit()后，如果超过最大线程数，就触发拒绝策略。</p>
<h2 id="结合业务分析线程池的使用"><a href="#结合业务分析线程池的使用" class="headerlink" title="结合业务分析线程池的使用"></a>结合业务分析线程池的使用</h2><p>并发高、任务执⾏时间短的业务怎样使⽤线程池？</p>
<p>并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？</p>
<p>并发⾼、 业务执⾏时间⻓的业务怎样使⽤线程池？ </p>
<ol>
<li><p>⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换。 </p>
</li>
<li><p>并发不⾼、任务执⾏时间⻓的业务要区分开看： </p>
<p>a）假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU 闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务。</p>
<p>b）假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（a）⼀样吧，线程池中的线 程数设置得少⼀些，减少线程上下⽂的切换。</p>
</li>
<li><p>并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数 据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题， 也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。</p>
</li>
</ol>
<h2 id="如果你提交任务时，线程池队列已满，这时会发⽣什么？"><a href="#如果你提交任务时，线程池队列已满，这时会发⽣什么？" class="headerlink" title="如果你提交任务时，线程池队列已满，这时会发⽣什么？"></a>如果你提交任务时，线程池队列已满，这时会发⽣什么？</h2><p>1、如果你使⽤的LinkedBlockingQueue，也就是⽆界队列的话，没关系，继续添加任务到阻塞队列中等待执⾏，因为 LinkedBlockingQueue可以近乎认为是⼀个⽆穷⼤的队列，可以⽆限存放任务； </p>
<p>2、如果你使⽤的是有界队列⽐⽅说ArrayBlockingQueue的话，任务⾸先会被添加到ArrayBlockingQueue中， ArrayBlockingQueue满了，则会使⽤拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。</p>
<h2 id="ThreadLocal作用"><a href="#ThreadLocal作用" class="headerlink" title="ThreadLocal作用"></a>ThreadLocal作用</h2><p>ThreadLocal可以实现资源对象的线程隔离，让每个线程各用各的资源对象，避免争用引发的线程安全问题。</p>
<p>ThreadLocal同时实现了线程内的资源共享。</p>
<h2 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h2><p>每个线程内有一个ThreadLocalMap类型的成员变量，用来存储资源对象。</p>
<ul>
<li><p>调用set方法时，就是以ThreadLocal自己作为key，资源对象作为value，放入当前线程的ThreadLocalMap中。</p>
</li>
<li><p>调用get方法时，就是以ThreadLocal自己作为key，到当前线程中查找关联的资源值。</p>
</li>
<li><p>调用remove方法时，就是以ThreadLocal自己作为key，移除当前线程关联的资源。</p>
</li>
</ul>
<h2 id="ThreadLocalMap中的key（即ThreadLocal）为什么要设计成弱引用"><a href="#ThreadLocalMap中的key（即ThreadLocal）为什么要设计成弱引用" class="headerlink" title="ThreadLocalMap中的key（即ThreadLocal）为什么要设计成弱引用"></a>ThreadLocalMap中的key（即ThreadLocal）为什么要设计成弱引用</h2><ul>
<li>Thread可能需要长时间运行（比如线程池中的线程），如果key不再使用，需要在内存不足（GC）时释放其占用的内存。</li>
<li>GC仅是让key的内存释放，后续还要根据key是否为null来进一步释放值的内存，释放时机有：<ol>
<li>获取key发现null key。</li>
<li>set key时，会使用启发式扫描，清除临近的null key，启发次数与元素个数、是否发现null key有关。</li>
<li>remove时（推荐），因为一般使用ThreadLocal时都把它作为<strong>静态变量</strong>，因此GC无法回收，需要我们手动调用remove方法进行清理，避免内存泄漏。</li>
</ol>
</li>
</ul>
<h2 id="⾼并发系统如何做性能优化？如何防⽌库存超卖？"><a href="#⾼并发系统如何做性能优化？如何防⽌库存超卖？" class="headerlink" title="⾼并发系统如何做性能优化？如何防⽌库存超卖？"></a>⾼并发系统如何做性能优化？如何防⽌库存超卖？</h2><ul>
<li><p>⾼并发系统性能优化： 优化程序，优化服务配置，优化系统配置</p>
<ol>
<li>尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。 </li>
<li>⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。 </li>
<li>优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。 </li>
<li>优化数据库结构，多做索引，提⾼查询效率。 </li>
<li>统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。 </li>
<li>能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。 </li>
<li>解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。</li>
</ol>
</li>
<li><p>防⽌库存超卖： </p>
<ol>
<li><p>悲观锁：在更新库存期间加锁，不允许其它线程修改；</p>
<ul>
<li>数据库锁：select xxx for update；</li>
<li>分布式锁；</li>
</ul>
</li>
<li><p>乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。 </p>
<ul>
<li>redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。</li>
</ul>
</li>
<li><p>消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。 </p>
</li>
<li><p>总结：总的来说，不能把压⼒放在数据库上，所以使⽤ “select xxx for update” 的⽅式在⾼并发的场景下是不可⾏ 的。FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤。所以相对来说，我会倾向于 选择：乐观锁 &#x2F; 缓存锁 &#x2F; 分布式锁的⽅式。</p>
</li>
</ol>
</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="JVM内存结构概述"><a href="#JVM内存结构概述" class="headerlink" title="JVM内存结构概述"></a>JVM内存结构概述</h2><p><img src="/20190101181900/image-20230302190512791.png" srcset="/img/loading.gif" lazyload alt="image-20230302190512791"></p>
<p>JVM内存结构概述：</p>
<ul>
<li><p>方法区：类的信息（包括方法等）。</p>
</li>
<li><p>堆：java实例对象。</p>
</li>
<li><p>栈：局部变量、方法参数、引用。</p>
</li>
<li><p>程序计数器：记录程序执行位置（用于进行类似线程上下文切换的操作）。</p>
</li>
<li><p>本地方法栈是一些系统方法，比如hashCode()。</p>
</li>
<li><p>*解释器：将字节码翻译成平台可执行的机器码，每执行一次代码都需要解释一次。</p>
</li>
<li><p>*即时编译器：缓存热点代码（频繁调用很多次的代码），从而不会一直用解释器。</p>
</li>
</ul>
<p>其中：</p>
<ul>
<li>线程私有：程序计数器、虚拟机栈。</li>
<li>线程共享：堆、方法区。</li>
</ul>
<h2 id="哪些部分会出现内存溢出"><a href="#哪些部分会出现内存溢出" class="headerlink" title="哪些部分会出现内存溢出"></a>哪些部分会出现内存溢出</h2><p>除了程序计数器以外，其他地方都有可能产生。</p>
<p>内存溢出类型：</p>
<ul>
<li>OutOfMemoryError<ol>
<li>对内存耗尽，对象越来越多，又一直在使用，不能被垃圾回收。</li>
<li>方法区内存耗尽，加载的类越来越多，很多框架都会在运行期间动态产生新的类。</li>
<li>虚拟机栈累积，每个线程最多会占用1M内存，线程个数越来越多，而又长时间运行不销毁时。（线程池可以避免该情况）</li>
</ol>
</li>
<li>StackOverflowError<ol>
<li>虚拟机栈内部，方法调用次数过多，比如无限递归。</li>
</ol>
</li>
</ul>
<h2 id="方法区与永久代、元空间的关系"><a href="#方法区与永久代、元空间的关系" class="headerlink" title="方法区与永久代、元空间的关系"></a>方法区与永久代、元空间的关系</h2><p>方法区，是JVM规范中定义的一块内存区域，用来存储元数据、方法字节码、即时编译器需要的信息等。</p>
<p>永久代，是Hotspot虚拟机对JVM规范的一种实现（<strong>1.8之前</strong>）。</p>
<p>元空间，是Hotspot虚拟机对JVM规范的一种实现（<strong>1.8之后</strong>），使用本地内存作为这些信息的存储空间。</p>
<h2 id="JVM内存参数"><a href="#JVM内存参数" class="headerlink" title="JVM内存参数"></a>JVM内存参数</h2><p>对于JVM内存配置参数：<code>-Xmx10240m -Xms10240m -Xmn5120m -XX:SurvivorRatio=3</code>，其最小内存值和Survivor区（from+to两个区）总大小分别是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs -Xmx```：JVM最大内存。"><br>```-Xms```：JVM最小内存。<br><br>```-Xmn```：新生代内存。<br><br>```-XX:NewRatio```：老年代与新生代的内存比例。<br><br>```-XX:SurvivorRatio```：新生代中，eden与from的比值（默认为8）。from和to是一直都是相等的。<br><br>![image-20230302195418507](面试笔记/image-20230302195418507.png)<br><br>如上图，eden:from=4:1，那么，相当于from占了整个新生代内存的1/6（from和to是一直都是相等的），所以题目中通过```-Xmn512m```和 ```-XX:SurvivorRatio=3```可以计算出```Survivor区总大小 = 5120 * 1/5 * 2 = 2048m``` 。<br><br>其他的大小设置：<br><br>![image-20230302200525112](面试笔记/image-20230302200525112.png)<br><br><br><br>## 垃圾回收算法<br><br>1. 标记清除<br><br>   ![image-20230302201712754](面试笔记/image-20230302201712754.png)<br><br>   从GC Root开始查找（GC Root是一定不能被清除的）引用链上的类，有被用到的就会被标记。清除清的是未被标记的。<br><br>   缺点：清除出来的内存不连续，会有内存碎片。<br><br>2. 标记整理<br><br>   ![image-20230303153558719](面试笔记/image-20230303153558719.png)<br><br>   优点：不会产生内存碎片。<br><br>   缺点：性能会低一些。<br><br>   该回收算法适用于老年代。<br><br>3. 标记复制<br><br>   ![image-20230303153800821](面试笔记/image-20230303153800821.png)<br><br>   将标记的对象复制到另一个内存区，然后将原来的内存进行回收。<br><br>   优点：不会产生内存碎片，也不需要进行整理。<br><br>   缺点：占用额外内存。<br><br>   该回收算法适用于新生代，不适用于老年代，因为老年代存活率高，要复制的对象多。<br><br><br><br>## GC和分代回收算法<br><br>* GC的目的在于实现无用对象内存的自动释放，减少内存碎片、加快分配速度。<br><br>  GC要点：<br><br>  1. 回收区域是堆内存，不包括虚拟机栈，在方法调用结束会自动释放方法占用内存。<br>  2. 判断无用对象：使用可达性分析算法，三色标记法标记存活对象，回收未标记对象。<br>  3. GC具体的实现成为垃圾回收器。<br>  4. GC大都采用了分代回收思想，理论依据是：大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收，根据这两类对象的特性将回收区域分为新生代和老年代，不同区域应用不同的回收策略。<br>  5. 根据GC的规模可以分成Minor GC、Mixed GC、Full GC。<br>     * Minor GC，发生在新生代的垃圾回收，暂停时间短。<br>     * Mixed GC，新生代+老年代部分区域的垃圾回收，G1收集器持有。<br>     * Full GC，新生代和老年代完整垃圾回收，暂停时间长，应尽量避免。<br><br>* 分代回收<br>  1. 伊甸园eden，最初对象都分配到这里，与幸存区合称新生代。<br>  2. 幸存区survivor，当伊甸园内存不足，回收后的幸存对象到这里，分成from和to，采用标记复制法，将eden和survivor（from区）标记的对象复制到to区，复制完成后进行回收，回收后将to区切换为from区。<br>  3. 老年代old，当幸存区对象熬过几次回收后（最多15次，4位计数，所以最多15次），晋升到老年代。幸存区内存不足或者有大对象会导致提前晋升。<br><br><br><br>## 三色标记与并发漏标问题<br><br>使用三种颜色记录对象的标记状态：<br><br>* 黑色，已标记。<br><br>* 灰色，标记中。<br><br>* 白色，还未标记。<br><br>解决并发漏标问题 - 记录标记过程中的变化：<br><br>1. Incremental Update（增量更新）<br><br>   只要赋值发生，被赋值的对象就会被记录。<br><br>2. Snapshot At The Beginning，SATB（初始快照）<br><br>   1. 新加对象会被记录<br>   2. 被删除引用关系的对象也会被记录<br><br>发生并发漏标后，会进行STW（Stop The World）暂停其他线程，进行重新标记。<br><br><br><br>## 垃圾回收器<br><br>* Parallel GC<br><br>  1. eden 内存不足发生Minor GC，标记复制STW。<br>  2. old 内存不足发生Full GC，标记整理STW。<br>  3. 注重吞吐量。<br><br>  虽然有STW，但是是多个线程进行并行的回收操作。<br><br>* ConcurrentMarkSweep GC（CMS，过时）<br><br>  1. old并发标记，重新标记时需要STW，并发清除，所以会有内存碎片。<br>  2. Failback Full GC，保底策略：失败时会触发 Full GC。<br>  3. 注重响应时间。<br><br>* G1 GC（JDK9）<br><br>  ![image-20230303163815477](面试笔记/image-20230303163815477.png)<br>  <br>  1. 响应时间与吞吐量兼顾<br>  2. 划分成多个区域，每个区域都可以充当edeen，survivor，old，humongous（大对象区）<br>  3. 回收机制：<br>     1. 新生代回收：eden内存不足，标记复制STW。<br>     2. 并发标记：老年代超过45%（默认），old并发标记，重新标记时需要STW。<br>     3. 混合收集：并发标记完成，开始混合收集，参与复制的有edeen，survivor，old，其中old会根据暂停时间目标，选择部分回收价值高（回收对象少，回收后可以释放更多内存）的区域，复制时STW。<br>     4. Failback Full GC。<br><br><br><br>## 常见的内存溢出<br><br>* [误用线程池导致的内存溢出](#误用线程池导致的内存溢出])<br>* [查询数据量太大导致的内存溢出](#查询数据量太大导致的内存溢出)<br>* [动态生成类导致的内存溢出](#动态生成类导致的内存溢出)<br><br><br><br>### 误用线程池导致的内存溢出<br><br>比如测试代码：<br><br>```java<br>package oom;<br><br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.TimeUnit;<br><br>/**<br> * 模拟短信发送超时时，仍有大量的任务进入队列<br> * 为方便测试，先修改运行内存为-Xmx8m<br> */<br>public class ThreadPoolTest &#123;<br>    public static void main(String[] args) &#123;<br>        // 使用工具类创建线程池，大小为2<br>        ExecutorService executor = Executors.newFixedThreadPool(2);<br>        while (true)&#123;<br>            executor.submit(()-&gt;&#123;<br>                System.out.println(&quot;发送短信相关业务逻辑...&quot;);<br>                try &#123;<br>                    // 模拟短信发送超时<br>                    TimeUnit.SECONDS.sleep(30);<br>                &#125; catch (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为方便测试，修改虚拟机配置：</p>
<p><img src="/20190101181900/image-20230303165422780.png" srcset="/img/loading.gif" lazyload alt="image-20230303165422780"></p>
<p><img src="/20190101181900/image-20230303220105748.png" srcset="/img/loading.gif" lazyload alt="image-20230303220105748"></p>
<p>运行后就会发现：</p>
<p><img src="/20190101181900/image-20230303170124012.png" srcset="/img/loading.gif" lazyload alt="image-20230303170124012"></p>
<p>1）误用<code>Executors.newFixedThreadPool(2);</code>，通过查看源码可以知道，它创建的是一个<code>LinkedBlockingQueue</code>，任务队列“无限”的线程池（实际上是<code>capacity = Integer.MAX_VALUE</code>），如果任务队列不断添加任务，占用内存导致内存溢出。</p>
<p><img src="/20190101181900/image-20230303220224329.png" srcset="/img/loading.gif" lazyload alt="image-20230303220224329"></p>
<p>2）误用<code>Executors.newCachedThreadPool();</code>，通过查看其源码可以知道，它创建的是一个有“无限”救助线程的线程池。</p>
<p><img src="/20190101181900/image-20230303230619879.png" srcset="/img/loading.gif" lazyload alt="image-20230303230619879"></p>
<h3 id="查询数据量太大导致的内存溢出"><a href="#查询数据量太大导致的内存溢出" class="headerlink" title="查询数据量太大导致的内存溢出"></a>查询数据量太大导致的内存溢出</h3><p>引入jol库：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jol（Java Object Layout，JVM中对象内存布局的小工具）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> oom;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> org.openjdk.jol.info.ClassLayout;<br><br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对象大小计算测试</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectMemoryTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 计算对象本身内存（不包含数据）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">objSize</span> <span class="hljs-operator">=</span> ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>()).instanceSize();<br>        System.out.println(objSize + <span class="hljs-string">&quot;字节&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;产品名称&quot;</span>;<br>        <span class="hljs-comment">// 字符串本身的大小，值是另外引用的</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">nameObjSize</span> <span class="hljs-operator">=</span> ClassLayout.parseInstance(name).instanceSize();<br>        System.out.println(nameObjSize);<br>        <span class="hljs-comment">// 字符串值的大小计算（+16是要算上String中byte[]数组对象本身大小）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nameSize</span> <span class="hljs-operator">=</span> name.getBytes(StandardCharsets.UTF_8).length + <span class="hljs-number">16</span>;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">desc</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;有关产品的具体描述信息，巴拉巴拉...&quot;</span>;<br>        <span class="hljs-comment">// 字符串本身的大小，值是另外引用的</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">descObjSize</span> <span class="hljs-operator">=</span> ClassLayout.parseInstance(desc).instanceSize();<br>        System.out.println(descObjSize);<br>        <span class="hljs-comment">// 字符串值的大小计算（+16是要算上byte[]数组对象本身大小）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">descSize</span> <span class="hljs-operator">=</span> name.getBytes(StandardCharsets.UTF_8).length + <span class="hljs-number">16</span>;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">totalSize</span> <span class="hljs-operator">=</span> nameObjSize + nameSize + descObjSize + descSize;<br>        System.out.println(totalSize);<br>        <span class="hljs-comment">// 再加上：ArrayList本身24，Object[]本身16，共40</span><br>        System.out.println((<span class="hljs-number">100000</span> * totalSize + <span class="hljs-number">40</span>) / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;Mb&quot;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 本次测试输出 9Mb（10万个这样的Product对象）</span><br><span class="hljs-comment">         * 所以数据量一旦很大，</span><br><span class="hljs-comment">         * 一个用户的findAll()查询 或者 条件失效的查询 将会占用很大的内存，导致内存溢出。</span><br><span class="hljs-comment">         */</span><br><br>    &#125;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> String desc;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>本次测试输出 9Mb（10万个这样的Product对象）<br>所以数据量一旦很大，一个或者多个用户的 <em><strong>findAll()查询</strong></em>  或者 <em><strong>条件失效的查询</strong></em> 将会占用很大的内存，导致内存溢出。</p>
<h3 id="动态生成类导致的内存溢出"><a href="#动态生成类导致的内存溢出" class="headerlink" title="动态生成类导致的内存溢出"></a>动态生成类导致的内存溢出</h3><p>比如这样一种情况：</p>
<p>有一个静态的类变量，它内部有个类加载器，可以动态创建类，每次调用它的某个方法就会动态创建类，因为这个类变量是静态的，所以是GC Root，它及其创建的类后在元空间中很难被回收，导致元空间内存溢出。以<code>GroovyShell</code>这个类为例：</p>
<p>测试配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--groovy脚本依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.groovy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>groovy-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>任意groovy脚本文件一个：</p>
<p><img src="/20190101181900/image-20230304005229494.png" srcset="/img/loading.gif" lazyload alt="image-20230304005229494"></p>
<p>为方便测试，修改JVM运行参数：</p>
<p><img src="/20190101181900/image-20230304005348282.png" srcset="/img/loading.gif" lazyload alt="image-20230304005348282"></p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> oom;<br><br><span class="hljs-keyword">import</span> groovy.lang.GroovyShell;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟不断生成类，但类无法卸载的情况</span><br><span class="hljs-comment"> * 为方便测试，运行参数设置-XX:MaxMetaspaceSize=32m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassMemoryTest</span> &#123;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">GroovyShell</span> <span class="hljs-variable">shell</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroovyShell</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">// 计数器</span><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 读取文件</span><br>            <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;script&quot;</span>);<br>            <span class="hljs-comment">// 加载脚本（会根据GroovyShell的类加载器GroovyClassLoader动态创建类）</span><br>            shell.evaluate(reader);<br>            System.out.println(mark.incrementAndGet());<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/20190101181900/image-20230304005405565.png" srcset="/img/loading.gif" lazyload alt="image-20230304005405565"></p>
<p>通过运行结果可以看到，在执行了2143次脚本之后，元空间的内存溢出了。</p>
<p>优化方法：将静态变量改为局部变量即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> oom;<br><br><span class="hljs-keyword">import</span> groovy.lang.GroovyShell;<br><br><span class="hljs-keyword">import</span> java.io.FileNotFoundException;<br><span class="hljs-keyword">import</span> java.io.FileReader;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟不断生成类，但类无法卸载的情况</span><br><span class="hljs-comment"> * 为方便测试，运行参数设置-XX:MaxMetaspaceSize=32m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassMemoryTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">// 计数器</span><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">// 修改为局部变量</span><br>            <span class="hljs-type">GroovyShell</span> <span class="hljs-variable">shell</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroovyShell</span>();<br>            <span class="hljs-comment">// 读取文件</span><br>            <span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;script&quot;</span>);<br>            <span class="hljs-comment">// 加载脚本（会根据GroovyShell的类加载器GroovyClassLoader动态创建类）</span><br>            shell.evaluate(reader);<br>            System.out.println(mark.incrementAndGet());<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>点击运行，接下来通过jconsole查看内存使用情况：</p>
<h4 id="通过java自带的jconsole工具来查看程序内存的使用情况"><a href="#通过java自带的jconsole工具来查看程序内存的使用情况" class="headerlink" title="通过java自带的jconsole工具来查看程序内存的使用情况"></a>通过java自带的jconsole工具来查看程序内存的使用情况</h4><p><em>注：运行环境一定要跟系统环境变量的版本一致，否则jconsole会一直连接失败。</em></p>
<p><img src="/20190101181900/image-20230304011018225.png" srcset="/img/loading.gif" lazyload alt="image-20230304011018225"></p>
<p><img src="/20190101181900/image-20230304011623249.png" srcset="/img/loading.gif" lazyload alt="image-20230304011623249"></p>
<p><img src="/20190101181900/image-20230304011645447.png" srcset="/img/loading.gif" lazyload alt="image-20230304011645447"></p>
<p><img src="/20190101181900/image-20230304011834362.png" srcset="/img/loading.gif" lazyload alt="image-20230304011834362"></p>
<p>通过jconsole可以看到，元空间的内存现在是不会满了，会自动回收，卸载没有用的类。</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>三个阶段：</p>
<ol>
<li>加载<ul>
<li>将类的字节码载入方法区，并创建类.class对象。</li>
<li>如果此类的父类没有加载，先加载父类。</li>
<li>加载是懒惰执行。</li>
</ul>
</li>
<li>链接<ul>
<li>验证 - 验证类是否符合class规范，合法性、安全性检查</li>
<li>准备 - 为static变量分配空间，设置默认值</li>
<li>解析 - 将常量池的符号引用解析为直接引用</li>
</ul>
</li>
<li>初始化<ul>
<li>执行静态代码块与<em><strong>非final</strong></em>的静态变量的赋值</li>
<li>初始化是懒惰执行</li>
</ul>
</li>
</ol>
<h3 id="jhsdb使用"><a href="#jhsdb使用" class="headerlink" title="jhsdb使用"></a>jhsdb使用</h3><p>查看方法：结合java自带的<code>jps</code>、<code>jhsdb</code>查看，需要注意的是，在idea中运行程序的jdk版本一定要和jps、jhsdb版本一致，否则会连接失败抛出异常：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Exception in thread <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-keyword">java.lang.RuntimeException: </span>Type <span class="hljs-string">&quot;GrowableArrayBase&quot;</span>, referenced in VMStructs::localHotSpotVMStructs in the remote VM, was not present in the remote VMStructs::localHotSpotVMTypes table (<span class="hljs-keyword">should </span>have <span class="hljs-keyword">been </span>caught in the <span class="hljs-built_in">debug</span> <span class="hljs-keyword">build </span>of that VM). Can not continue.<br></code></pre></td></tr></table></figure>

<p><em><strong>附：8之后的jdk在安装时会一并安装一个在…&#x2F;oracle&#x2F;…目录下，从而导致jdk版本修改不生效问题。</strong></em></p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> classload;<br><br><span class="hljs-keyword">import</span> lombok.Data;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 类加载过程测试</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoadTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;未使用到Student&quot;</span>);<br>        <span class="hljs-comment">// 阻塞，通过jhsdb查看Student查看类加载情况</span><br>        System.in.read();<br><br>        System.out.println(Student.class);<br>        System.out.println(<span class="hljs-string">&quot;已加载Student&quot;</span>);<br>        <span class="hljs-comment">// 阻塞，通过jhsdb查看Student查看类加载情况</span><br>        System.in.read();<br><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(<span class="hljs-string">&quot;已初始化Student&quot;</span>);<br>        <span class="hljs-comment">// 阻塞，通过jhsdb查看Student查看类加载情况</span><br>        System.in.read();<br>    &#125;<br><br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>        <span class="hljs-keyword">private</span> String name;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>运行程序，此时程序在指定位置阻塞：</p>
<p><img src="/20190101181900/image-20230304161451547.png" srcset="/img/loading.gif" lazyload alt="image-20230304161451547"></p>
<p>通过jps查看程序运行的进程号：</p>
<p><img src="/20190101181900/image-20230304162323655.png" srcset="/img/loading.gif" lazyload alt="image-20230304162323655"></p>
<p>打开<code>jhsdb hsdb</code>命令打开hsdb，并建立连接，输入前面查询到的进程号：</p>
<p><img src="/20190101181900/image-20230304162445334.png" srcset="/img/loading.gif" lazyload alt="image-20230304162445334"></p>
<p><img src="/20190101181900/image-20230304162520513.png" srcset="/img/loading.gif" lazyload alt="image-20230304162520513"></p>
<p>连接成功后，通过 Class Browser 查看类加载情况：</p>
<p><img src="/20190101181900/image-20230304162621644.png" srcset="/img/loading.gif" lazyload alt="image-20230304162621644"></p>
<p>此时无法查看到Student类：</p>
<p><img src="/20190101181900/image-20230304162720475.png" srcset="/img/loading.gif" lazyload alt="image-20230304162720475"></p>
<p>我们<strong>先断开连接（必须，否则程序无法继续执行）</strong>：</p>
<p><img src="/20190101181900/image-20230304162749996.png" srcset="/img/loading.gif" lazyload alt="image-20230304162749996"></p>
<p>在程序的控制台进行输入操作（回车一下即可），让程序继续执行：</p>
<p><img src="/20190101181900/image-20230304163017504.png" srcset="/img/loading.gif" lazyload alt="image-20230304163017504"></p>
<p>这时我们再连接jhsdb查看类加载情况，发现类已经加载了：</p>
<p><img src="/20190101181900/image-20230304163140472.png" srcset="/img/loading.gif" lazyload alt="image-20230304163140472"></p>
<p>查看jvm内存情况：</p>
<p><img src="/20190101181900/image-20230305132528648.png" srcset="/img/loading.gif" lazyload alt="image-20230305132528648"></p>
<p>通过<code>help</code>命令可以查看到相关的命令。</p>
<p>其中，<code>universe</code>命令可以查看内存分布以及大小：</p>
<p><img src="/20190101181900/image-20230305132802644.png" srcset="/img/loading.gif" lazyload alt="image-20230305132802644"></p>
<p><code>g1regiondetails</code>命令可以查看G1的内存分布情况：</p>
<p><img src="/20190101181900/image-20230305132952463.png" srcset="/img/loading.gif" lazyload alt="image-20230305132952463"></p>
<h3 id="查看字节码文件"><a href="#查看字节码文件" class="headerlink" title="查看字节码文件"></a>查看字节码文件</h3><p>在 <code>/target/class/</code> 目录的命令行通过 <code>javap -c -v -p XXX.class</code> 可以查看到，如：</p>
<p><img src="/20190101181900/image-20230306122237450.png" srcset="/img/loading.gif" lazyload alt="image-20230306122237450"></p>
<p>上面的示例中，前两个线程是通过Lambda表达式创建的，线程t3则是通过匿名内部类的方式创建，其区别在于：</p>
<h4 id="扩展：Lambda表达式和匿名内部类的区别"><a href="#扩展：Lambda表达式和匿名内部类的区别" class="headerlink" title="扩展：Lambda表达式和匿名内部类的区别"></a>扩展：Lambda表达式和匿名内部类的区别</h4><ul>
<li><p>所需类型不同</p>
<p>匿名内部类：可以是接口，也可以是抽象类，还可以是具体类。</p>
<p>Lambda表达式：只能是接口</p>
</li>
<li><p>使用限制不同</p>
<p>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类。</p>
<p>如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式。</p>
</li>
<li><p>实现原理不同</p>
<p>匿名内部类：编译之后，产生一个单独的.class字节码文件。</p>
<p>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成。</p>
<p><img src="/20190101181900/image-20230306124500835.png" srcset="/img/loading.gif" lazyload alt="image-20230306124500835"></p>
</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>指优先委派上级类加载器进行加载，如果上级类加载器：</p>
<ul>
<li>能找到这个类，由上级加载，加载后该类也对下级加载器可见。</li>
<li>不能找到这个类，则下级类加载器才有资格执行加载。</li>
</ul>
<p><img src="/20190101181900/image-20230306130142595.png" srcset="/img/loading.gif" lazyload alt="image-20230306130142595"></p>
<p>双亲委派的目的：</p>
<ol>
<li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到jdk提供的核心类。</p>
</li>
<li><p>让类的加载有优先顺序，保证核心类优先加载。</p>
</li>
</ol>
<h4 id="能不能自己写一个java-lang-System类？"><a href="#能不能自己写一个java-lang-System类？" class="headerlink" title="能不能自己写一个java.lang.System类？"></a>能不能自己写一个java.lang.System类？</h4><p><img src="/20190101181900/image-20230306130602793.png" srcset="/img/loading.gif" lazyload alt="image-20230306130602793"></p>
<h2 id="对象的引用类型分为哪几种"><a href="#对象的引用类型分为哪几种" class="headerlink" title="对象的引用类型分为哪几种"></a>对象的引用类型分为哪几种</h2><ol>
<li><p>强引用</p>
<p>普通变量复制即为强引用，如 A a &#x3D; new A();</p>
<p>通过GC Root的引用链，如果强引用找不到对象，该对象才能被回收。</p>
</li>
<li><p>软引用</p>
</li>
<li><p>弱引用</p>
</li>
<li><p>虚引用</p>
</li>
</ol>
<h2 id="finalize-相关"><a href="#finalize-相关" class="headerlink" title="finalize()相关"></a>finalize()相关</h2><p>它是一个Object中的一个方法，子类重写它，垃圾回收时此方法会被调用，可以在其中进行一些资源释放和清理操作，但是这样操作非常不好，非常影响性能，严重时会引起OOM，所以从JDK9开始就被标记为过时方法了。</p>
<p>存在的问题：</p>
<ol>
<li>finalize()方法的调用次序并不能保证。</li>
<li>finalize()是Finalizer这个守护线程去执行的。</li>
<li>finalize()中的代码并不能保证被执行。</li>
<li>如果finalize()中出现异常，异常不会被输出。</li>
<li>垃圾回收时会立刻调用finalize()方法吗？</li>
</ol>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="解释-Spring-支持的几种-bean-的作用域"><a href="#解释-Spring-支持的几种-bean-的作用域" class="headerlink" title="解释 Spring 支持的几种 bean 的作用域"></a>解释 Spring 支持的几种 bean 的作用域</h2><p>Spring 框架支持以下五种 bean 的作用域：</p>
<ul>
<li>singleton : bean 在每个 Spring ioc 容器中只有一个实例。</li>
<li>prototype：一个 bean 的定义可以有多个实例。</li>
<li>request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>
<li>session：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域 仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>
<li>global-session：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实 例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。</li>
<li>缺省的 Spring bean 的作用域是 Singleton。</li>
</ul>
<h2 id="Spring-框架中的单例-Beans-是线程安全的么？"><a href="#Spring-框架中的单例-Beans-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Beans 是线程安全的么？"></a>Spring 框架中的单例 Beans 是线程安全的么？</h2><p>Spring 框架并没有对单例 bean 进行任何多线程的封装处理。关于单例 bean 的线程安全和并发问 题需要开发者自行去搞定。但实际上，大部分的 Spring bean 并没有可变的状态(比如 Serview 类 和 DAO 类)，所以在某种程度上说 Spring 的单例 bean 是线程安全的。如果你的 bean 有多种状 态的话（比如 View Model 对象），就需要自行保证线程安全。 最浅显的解决办法就是将多态 bean 的作用域由“singleton”变更为“prototype”。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" class="category-chain-item">技术分享</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E5%BE%85%E5%88%86%E7%B1%BB/" class="category-chain-item">待分类</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试笔记</div>
      <div>https://binbiubiu.github.io/20190101181900/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Binbiubiu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年1月1日</div>
        </div>
      
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/20190326120000/" title="获取抖音无水印视频（捷径）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">获取抖音无水印视频（捷径）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/20180907130000/" title="windows中通过命令行解决Tomcat端口被占用问题">
                        <span class="hidden-mobile">windows中通过命令行解决Tomcat端口被占用问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <i class="iconfont icon-love"></i> 技术支持： <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> |  <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
